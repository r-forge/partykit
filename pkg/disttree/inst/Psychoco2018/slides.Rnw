\documentclass[11pt,t,usepdftitle=false,aspectratio=43]{beamer}
%\usetheme[nototalframenumber, noslidenumber, url]{uibk}
\usetheme[nototalframenumber, noslidenumber]{uibk}

\title{Distributional Regression Forests for Probabilistic Modeling and Forecasting}
\author{Lisa Schlosser, Torsten Hothorn, Heidi Seibold, Achim Zeileis}
\setbeamerfont{url}{size*={11.5pt}{13pt},series=\mdseries}
\URL{https://eeecon.uibk.ac.at/~zeileis/}
\headerimage{4}


\setbeamertemplate{caption}{\insertcaption} 
%% includes a replacement for \usepackage{Sweave}
\usepackage{amsmath,tikz}
\usetikzlibrary{positioning,shapes,arrows,decorations.pathreplacing,calc,automata,mindmap}
\graphicspath{{plots/}}
\usepackage{geometry}

%% colors
\definecolor{HighlightOrange}{rgb}{0.9490196,0.5725490,0.0000000}
\definecolor{HighlightBlue}{rgb}{0.4784314,0.7490196,0.9803922}

 
\SweaveOpts{engine=R, eps=FALSE, keep.source=TRUE}
<<preliminaries, echo=FALSE, results=hide>>=
options(prompt = "R> ", continue = "+  ", useFancyQuotes = FALSE, width = 70)
library("ggplot2")
theme_set(theme_bw(base_size = 18))
library("disttree")
#library("partykitR1")
library("gamlss")
library("lattice")
library("crch")
library("latex2exp")
library("parallel")
library("gamlss.cens")
gen.cens(NO, type = "left")

## HCL palette
pal <- hcl(c(10, 128, 260), 100, 50)
names(pal) <- c("forest", "tree", "gamlss")

pallight <- hcl(c(10, 128, 260), 100, 50, alpha = 0.25)
names(pallight) <- c("forest", "tree", "gamlss")

transpgrey <- rgb(0.190,0.190,0.190, alpha = 0.2)



######## data generating process based on a predefined tree or a parameter function
# if tree: 2 splits => 3 terminal nodes
# 10 split variables (x1, ..., x10) are availabe (5 numeric, 2 binary, 3 categorical)
#
# input: n            ..... nr of observations
#        family       ..... distribution of the generated observations
#        split.matrix ..... indices of the variables used for the splits together with the corresponding split points
#        parm.matrix  ..... set of distribution parameters for each subgroup
#        fun          ..... parameter function
#
# output: data.frame with generated observations y (generated seperatly in each subgroups with given distributions parameters),
#                         the given split variables x1, ..., x10 for each observation and
#                         the index of the subgroup for each observation or
#                         the distribution parameter for each observation

# FIX: until now only complete lists can be handed over (dist_list...)
dgp <- function(n, family = dist_list_normal, 
                fun = NULL,
                split.matrix = matrix(nrow = 2, ncol = 2), 
                par.matrix = matrix(nrow = 3, ncol = 2), 
                round.sp = 3)
{
  
  # generating the possible split variables
  x1 <- runif(n,-0.4,1)
  x2 <- runif(n,-10,10)
  x3 <- runif(n,0,100)
  x4 <- x1 + rnorm(n, sd = 0.1)
  x5 <- x1 + rnorm(n, sd = 0.3)
  x6 <- rbinom(n,1,0.5)
  x7 <- rbinom(n,1,0.5)
  x8 <- sample(1:4, n, replace = TRUE) 
  x9 <- sample(1:5, n, replace = TRUE) 
  x10 <- sample(1:7, n, replace = TRUE)
  #x11 <- runif(n,-0.5,1)
  x <- cbind(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10)
  # reduce nr of possible split points by rounding values of split variables
  x <- round(x, digits = round.sp)
  
  y <- vector(mode = "numeric", length = n)
  
  # getting the random function
  if(is.function(family)) family <- family()
  if(inherits(family, "gamlss.family")) {
    rfun <- get(paste0("r",family$family[[1]]))
  } else {
    if(family$family.name == "Normal Distribution") rfun <- rNO
    if(family$family.name == "censored Normal Distribution") rfun <- rNO
    if(family$family.name == "Poisson Distribution") rfun <- rPO
    if(family$family.name == "Weibull Distribution") rfun <- survival:::rsurvreg 
  }
  
  
  if(is.null(fun)) {
    index <- vector(mode = "numeric", length = n)
    sv = split.matrix[,1]    # index of split variables
    sp = split.matrix[,2]    # split points
    par = par.matrix
    
    # splitting based on the given split variables and split points and
    # generating the observations seperatly for each subgroup (with the corresponding given distribution parameters)
    for(k in 1:n){
      if(x[k, sv[1]] <= sp[1]){
        y[k] <- do.call(rfun, as.list(c(1,par[1,])))
        index[k] <- 2L
      } else {
        if(x[k, sv[2]] <= sp[2]){
          y[k] <- do.call(rfun, as.list(c(1,par[2,]))) 
          index[k] <- 4L
        } else {
          y[k] <- do.call(rfun, as.list(c(1,par[3,])))
          index[k] <- 5L
        }
      }
    }
    d <- as.data.frame(cbind(y, x, index))
    colnames(d) <- c("y", paste0("x", c(1:10)), "index")
    
  } else {
    
    dpar <- fun(x)
    
    if(!(family$family.name == "Poisson Distribution")){
      y <- rfun(n, dpar[,1], dpar[,2])
      d <- as.data.frame(cbind(y, x, dpar))
      colnames(d) <- c("y", paste0("x", c(1:10)), "mu", "sigma")
    } else {
      y <- rfun(n, dpar)
      d <- as.data.frame(cbind(y, x, dpar))
      colnames(d) <- c("y", paste0("x", c(1:10)), "lambda")
    }
  }
  
  
  if(family$family.name == "censored Normal Distribution") {
    #d$ystar <- d$y
    d$y <- pmax(d$y, 0)
  }
  
  return(d)
}






############################################ 
# parameter functions

### plotting function for one data set
plot1 <- function(learndata, dt=NULL, df=NULL, g=NULL, all.par = FALSE, df.par = FALSE, g.par = FALSE, dt.par = FALSE, all.var = FALSE) 
{
  plotdata <- cbind(learndata[,c("y","x1","mu","sigma")],
                    df$fitted.par,
                    dt$fitted.par,
                    #coef(dt)[paste(dt$fitted[,1]),],
                    g$mu.fv, g$sigma.fv)
  
  colnames(plotdata) <- c("y","x1","true.mu","true.sigma", 
                          "fitted.mu.df","fitted.sigma.df",
                          "fitted.mu.dt","fitted.sigma.dt",
                          "fitted.mu.g","fitted.sigma.g")
  sp <- plotdata[order(plotdata["x1"]),]
  

  if(!(any(dt.par, df.par, g.par, all.par, all.var))){
    par(mar=c(5.1,4.1,4.1,3.1))
    plot(y = sp$y, x = sp$x, type = "p", col="grey", main = "True parameters", cex.main = 1.2, xaxt="n", yaxt="n", xlab = "", ylab = "")
    lines(x = sp$x, y = sp$true.mu, type = "l", col = 'black')
    polygon(c(sp$x, rev(sp$x)), c(sp$true.mu + sp$true.sigma, rev(sp$true.mu - sp$true.sigma)),
  col = transpgrey, border = "transparent")
    #lines(x = sp$x, y = sp$true.mu + sp$true.sigma, type = "l", lty = 1, col = 'grey')
    #lines(x = sp$x, y = sp$true.mu - sp$true.sigma, type = "l", lty = 1, col = 'grey')
    #legend('topleft', c(TeX('$\\mu$'), TeX('$\\mu \\pm \\sigma$')), 
    #       col = c('black', transpgrey), lty = 1, bty = "n", lwd = 2.5)
    legend(x = -0.5, y = 14, expression(mu %+-% sigma), bty = "n")
  }
  
  # disttree
  if(dt.par){
    par(mar=c(5.1,4.1,4.1,3.1))
    plot(y = sp$y, x = sp$x, type = "p", col="grey", main = "disttree", col.main = pal["tree"], cex.main = 1.2, xaxt="n", yaxt="n", xlab = "", ylab = "")
    lines(x = sp$x, y = sp$true.mu, type = "l", col = 'black')
    #polygon(c(sp$x, rev(sp$x)), c(sp$true.mu + sp$true.sigma, rev(sp$true.mu - sp$true.sigma)),
    #col = transpgrey, border = "transparent")
    lines(x = sp$x, y = sp$true.mu + sp$true.sigma, type = "l", col = 'grey')
    lines(x = sp$x, y = sp$true.mu - sp$true.sigma, type = "l", col = 'grey')
    lines(x = sp$x, y = sp$fitted.mu.dt, type = "l", col = pal["tree"], lwd = 2.5)
    polygon(c(sp$x, rev(sp$x)), c(sp$fitted.mu.dt + sp$fitted.sigma.dt, rev(sp$fitted.mu.dt - sp$fitted.sigma.dt)),
  col = pallight["tree"], border = "transparent")
    #lines(x = sp$x, y = sp$fitted.mu.dt + sp$fitted.sigma.dt, type = "l", col = 'greenyellow')
    #lines(x = sp$x, y = sp$fitted.mu.dt - sp$fitted.sigma.dt, type = "l", col = 'greenyellow')
    #legend('topleft', c(TeX('$\\mu$'), TeX('$\\mu \\pm \\sigma$'), 
    #                    TeX('$\\hat{\\mu}$'), TeX('$\\hat{\\mu} \\pm \\hat{\\sigma}$')), 
    #       col = c('black','grey', pal["tree"], pallight["tree"]), lty = 1, bty = "n", lwd = 2.5)
    legend(x = -0.5, y = 14, expression(mu %+-% sigma), bty = "n")
  }
  
  # distforest
  if(df.par){
    par(mar=c(5.1,4.1,4.1,3.1))
    plot(y = sp$y, x = sp$x, type = "p", col="grey", main = "distforest", col.main = pal["forest"], cex.main = 1.2, xaxt="n", yaxt="n", xlab = "", ylab = "")
    lines(x = sp$x, y = sp$true.mu, type = "l", col = 'black')
    #polygon(c(sp$x, rev(sp$x)), c(sp$true.mu + sp$true.sigma, rev(sp$true.mu - sp$true.sigma)),
    #col = transpgrey, border = "transparent")
    lines(x = sp$x, y = sp$true.mu + sp$true.sigma, type = "l", col = 'grey')
    lines(x = sp$x, y = sp$true.mu - sp$true.sigma, type = "l", col = 'grey')
    lines(x = sp$x, y = sp$fitted.mu.df, type = "l", col = pal["forest"], lwd = 2.5)
    polygon(c(sp$x, rev(sp$x)), c(sp$fitted.mu.df + sp$fitted.sigma.df, rev(sp$fitted.mu.df - sp$fitted.sigma.df)),
  col = pallight["forest"], border = "transparent")
    #lines(x = sp$x, y = sp$fitted.mu.df + sp$fitted.sigma.df, type = "l", col = 'orange')
    #lines(x = sp$x, y = sp$fitted.mu.df - sp$fitted.sigma.df, type = "l", col = 'orange')
    #legend('topleft', c(TeX('$\\mu$'), TeX('$\\mu \\pm \\sigma$'), 
    #                    TeX('$\\hat{\\mu}$'), TeX('$\\hat{\\mu} \\pm \\hat{\\sigma}$')), 
    #       col = c('black','grey',pal["forest"], pallight["forest"]), lty = 1, bty = "n", lwd = 2.5)
    legend(x = -0.5, y = 14, expression(mu %+-% sigma), bty = "n")
  }

  
  # gamlss
  if(g.par){
    par(mar=c(5.1,4.1,4.1,3.1))
    plot(y = sp$y, x = sp$x, type = "p", col="grey",  main = "gamlss", col.main = pal["gamlss"], cex.main = 1.2, xaxt="n", yaxt="n", xlab = "", ylab = "")
    lines(x = sp$x, y = sp$true.mu, type = "l", col = 'black')
    #polygon(c(sp$x, rev(sp$x)), c(sp$true.mu + sp$true.sigma, rev(sp$true.mu - sp$true.sigma)),
    #col = transpgrey, border = "transparent")
    lines(x = sp$x, y = sp$true.mu + sp$true.sigma, type = "l", col = 'grey')
    lines(x = sp$x, y = sp$true.mu - sp$true.sigma, type = "l", col = 'grey')
    lines(x = sp$x, y = sp$fitted.mu.g, type = "l", col = pal["gamlss"], lwd = 2.5)
    polygon(c(sp$x, rev(sp$x)), c(sp$fitted.mu.g + sp$fitted.sigma.g, rev(sp$fitted.mu.g - sp$fitted.sigma.g)),
  col = pallight["gamlss"], border = "transparent")
    #lines(x = sp$x, y = sp$fitted.mu.g + sp$fitted.sigma.g, type = "l", col = 'lightblue')
    #lines(x = sp$x, y = sp$fitted.mu.g - sp$fitted.sigma.g, type = "l", col = 'lightblue')
    #legend('topleft', c(TeX('$\\mu$'), TeX('$\\mu \\pm \\sigma$'), 
    #                    TeX('$\\hat{\\mu}$'), TeX('$\\hat{\\mu} \\pm \\hat{\\sigma}$')),  
    #       col = c('black','grey',pal["gamlss"], pallight["gamlss"]), lty = 1, bty = "n", lwd = 2.5)
    legend(x = -0.5, y = 14, expression(mu %+-% sigma), bty = "n")
  }
  
  # disttree vs. distforest vs. gamlss
  if(all.par){
    par(mar=c(5.1,4.1,4.1,3.1))
    plot(y = sp$y, x = sp$x, type = "p", col="grey", xaxt="n", yaxt="n", xlab = "", ylab = "")
    title(main = "disttree", col.main = pal["tree"], cex.main = 1.2, font.main = 2, adj = 0.19)
    title(main = "distforest", col.main = pal["forest"], cex.main = 1.2, font.main = 2, adj = 0.5)
    title(main = "gamlss", col.main = pal["gamlss"], cex.main = 1.2, font.main = 2, adj = 0.8)
    title(main = "vs.", col.main = "black", cex.main = 1.2, font.main = 2, adj = 0.35)
    title(main = "vs.", col.main = "black", cex.main = 1.2, font.main = 2, adj = 0.65)
    
    lines(x = sp$x, y = sp$true.mu, type = "l", col = 'black')
    lines(x = sp$x, y = sp$fitted.mu.dt, type = "l", col = pal["tree"], lwd = 2)
    lines(x = sp$x, y = sp$fitted.mu.df, type = "l", col = pal["forest"], lwd = 2)
    lines(x = sp$x, y = sp$fitted.mu.g, type = "l", col = pal["gamlss"], lwd = 2)
    #legend('topleft', c(TeX('$\\mu$'), TeX('$\\hat{\\mu}$ disttree'),
    #                    TeX('$\\hat{\\mu}$ distforest'), TeX('$\\hat{\\mu}$ gamlss')), 
    #       col = c('black',pal["tree"],pal["forest"],pal["gamlss"]), lty = 1, bty = "n", lwd = 2.5)
    legend(x = -0.5, y = 13.95, expression(mu), bty = "n")
  }
  
  # variance: disttree vs. distforest vs. gamlss
  if(all.var){
    par(mar=c(5.1,4.1,4.1,3.1))
    plot(y = sp$y, x = sp$x, type = "p", col="grey", xaxt="n", yaxt="n", xlab = "", ylab = "")
    title(main = "disttree", col.main = pal["tree"], cex.main = 1.2, font.main = 2, adj = 0.19)
    title(main = "distforest", col.main = pal["forest"], cex.main = 1.2, font.main = 2, adj = 0.5)
    title(main = "gamlss", col.main = pal["gamlss"], cex.main = 1.2, font.main = 2, adj = 0.8)
    title(main = "vs.", col.main = "black", cex.main = 1.2, font.main = 2, adj = 0.35)
    title(main = "vs.", col.main = "black", cex.main = 1.2, font.main = 2, adj = 0.65)
    
    #polygon(c(sp$x, rev(sp$x)), c(sp$true.mu + sp$true.sigma, rev(sp$true.mu - sp$true.sigma)),
    #col = transpgrey, border = "transparent")
    lines(x = sp$x, y = sp$true.mu + sp$true.sigma, type = "l", col = 'black')
    lines(x = sp$x, y = sp$true.mu - sp$true.sigma, type = "l", col = 'black')
    polygon(c(sp$x, rev(sp$x)), c(sp$fitted.mu.dt + sp$fitted.sigma.dt, rev(sp$fitted.mu.dt - sp$fitted.sigma.dt)),
  col = pallight["tree"], border = "transparent")
    #lines(x = sp$x, y = sp$fitted.mu.dt + sp$fitted.sigma.dt, type = "l", col = pal["tree"], lwd = 2)
    #lines(x = sp$x, y = sp$fitted.mu.dt - sp$fitted.sigma.dt, type = "l", col = pal["tree"], lwd = 2)
    polygon(c(sp$x, rev(sp$x)), c(sp$fitted.mu.df + sp$fitted.sigma.df, rev(sp$fitted.mu.df - sp$fitted.sigma.df)),
  col = pallight["forest"], border = "transparent")
    #lines(x = sp$x, y = sp$fitted.mu.df + sp$fitted.sigma.df, type = "l", col = pal["forest"], lwd = 2)
    #lines(x = sp$x, y = sp$fitted.mu.df - sp$fitted.sigma.df, type = "l", col = pal["forest"], lwd = 2)
    polygon(c(sp$x, rev(sp$x)), c(sp$fitted.mu.g + sp$fitted.sigma.g, rev(sp$fitted.mu.g - sp$fitted.sigma.g)),
  col = pallight["gamlss"], border = "transparent")
    #lines(x = sp$x, y = sp$fitted.mu.g + sp$fitted.sigma.g, type = "l", col = pal["gamlss"], lwd = 2)
    #lines(x = sp$x, y = sp$fitted.mu.g - sp$fitted.sigma.g, type = "l", col = pal["gamlss"], lwd = 2)
    #legend('topleft', c(TeX('$\\mu \\pm \\sigma$'), TeX('$\\hat{\\mu} \\pm \\hat{\\sigma}$ disttree'),
    #                    TeX('$\\hat{\\mu} \\pm \\hat{\\sigma}$ distforest'), TeX('$\\hat{\\mu} \\pm \\hat{\\sigma}$ gamlss')), 
    #       col = c('black',pal["tree"],pal["forest"],pal["gamlss"]), lty = 1, bty = "n", lwd = 2.5)
  legend(x = -0.5, y = 14, expression(mu %+-% sigma), bty = "n")
  }
  
}

@




\begin{document}

\section{Distributional Trees and Forests}

\subsection{Motivation}

\begin{frame}[fragile]
\frametitle{Motivation}
\vspace{-0.41cm}
\begin{figure}[!htb]
\minipage{0.28\textwidth}
\begin{center}
<<motivation_GLM, echo=FALSE, results=hide>>=
nobs <- 200
## GLM
set.seed(7)
x <- c(1:nobs)/nobs
ytrue <- 1+x*1.5
y <- ytrue + rnorm(nobs,0,0.3)
@
\visible<2->{
<<plot_motivation_GLM, fig=TRUE, echo=FALSE>>=
par(mar=c(2,0,2,0))
plot(y=y , x=x, xaxt="n", yaxt="n", ann=FALSE, col = "slategray", pch = 19)
box(lwd=5)
lines(x = x, y = ytrue, col = pal["forest"], lwd = 7, main = "")
@
}
\end{center}
\endminipage
\visible<3->{{\LARGE$\rightarrow$}}
\minipage{0.28\textwidth}
\begin{center}
<<motivation_GAM, echo=FALSE, results=hide>>=
## GAM
set.seed(7)
x <- c(1:nobs)/nobs
x <- 2*(x-0.5)
ytrue <- x^3 
y <- ytrue + rnorm(nobs,0,0.3)
@
\visible<3->{
<<plot_motivation_GAM, fig=TRUE, echo=FALSE>>=
par(mar=c(2,0,2,0))
plot(y=y , x=x, xaxt="n", yaxt="n", ann=FALSE, col = "slategray", pch = 19)
box(lwd=5)
lines(x = x, y = ytrue, col = pal["forest"], lwd = 7, main = "")
@
}
\end{center}
\endminipage
\visible<4->{{\LARGE$\rightarrow$}}
\minipage{0.28\textwidth}
\begin{center}
<<motivation_GAMLSS, echo=FALSE, results=hide>>=
## GAMLSS
set.seed(7)
x <- c(1:nobs)/nobs
x <- 2*(x-0.5)
ytrue <- x^3
var <- exp(-(2*x)^2)/2
y <- ytrue + rnorm(nobs, 0, 0.1 + var)
@
\visible<4->{
<<plot_motivation_GAMLSS, fig=TRUE, echo=FALSE>>=
par(mar=c(2,0,2,0))
plot(x, y, xaxt = "n", yaxt = "n", ann = FALSE, type = "n")
polygon(c(x, rev(x)), c(ytrue + 0.1 + var, rev(ytrue - 0.1 - var)),
  col = pallight["forest"], border = "transparent")
lines(x, ytrue, col = pal["forest"], lwd=7)
points(x, y, col = "slategray", pch = 19)
box(lwd = 5)
@

}
\end{center}
\endminipage

\vspace{0.5cm}
\minipage{0.25\textwidth}
\begin{center}
\visible<2->{
LM, GLM\\
\vspace{0.5cm}
\code{lm}\\
\code{glm}\\
\vspace{1.5cm}}
\end{center}
\endminipage
\hspace{1.1cm}
\minipage{0.25\textwidth}
\begin{center}
\visible<3->{
GAM\\
\vspace{0.5cm}
\code{mgcv}\\
\code{VGAM}\\
$\ldots$\\
\vspace{1cm}}
\end{center}
\endminipage
\hspace{1.1cm}
\minipage{0.25\textwidth}
\begin{center}
\visible<4->{
GAMLSS\\
\vspace{0.5cm}
\code{gamlss}\\
\code{mgcv}\\
\code{VGAM}\\
\code{gamboostLSS}\\
$\ldots$}
\end{center}
\endminipage
\end{figure}
\end{frame}




\begin{frame}[fragile]
\frametitle{Motivation}
\vspace{-0.2cm}
\begin{figure}[!htb]
\minipage{0.28\textwidth}
\begin{center}
<<motivation_regtree, echo=FALSE, results=hide>>=
## Reg. Tree
set.seed(7)
kappa <- 12
x <- c(1:nobs)/nobs
ytrue <- ytree <- yforest <- numeric(length = length(x))
for(i in 1:nobs) ytrue[i] <- if(x[i]<1/3) 0.5 else 1+(1-plogis(kappa*(2*(x[i]-0.2)-1)))
y <- ytrue + rnorm(nobs,0,0.3)
for(i in 1:nobs) ytree[i] <- if(x[i]<1/3) 0.5 else {if(x[i]<2/3) 2 else 1}
@
\visible<1->{
<<plot_motivation_regtree, fig=TRUE, echo=FALSE>>=
par(mar=c(2,0,2,0))
plot(x = x, y = y, xaxt="n", yaxt="n", ann=FALSE, col = "slategray", pch = 19)
box(lwd=5)
#lines(x = x, y = ytrue, col = "grey", lwd=5, main = "")
lines(x = x, y = ytree, col = pal["forest"], lwd=7)
@
}
\end{center}

\endminipage
\visible<2->{{\LARGE$\rightarrow$}}
\minipage{0.28\textwidth}
 \begin{center}
<<motivation_randforest, echo=FALSE, results=hide>>=
## Random Forest
for(i in 1:nobs) yforest[i] <- if(x[i]<0.27) 0.5 else { if(x[i]<0.39) 0.5 + 1.5*(plogis((x[i]-0.33)/6*700)) else 1+(1-plogis(kappa*(2*(x[i]-0.2)-1)))}
@
\visible<2->{
<<plot_motivation_randforest, fig=TRUE, echo=FALSE>>=
par(mar=c(2,0,2,0))
plot(x = x, y = y, xaxt="n", yaxt="n", ann=FALSE, col = "slategray", pch = 19)
box(lwd=5)
#lines(x = x, y = ytrue, col = "grey", lwd=5, main = "")
lines(x = x, y = yforest, col = pal["forest"], lwd=7, main = "")
@
}
\end{center}

\endminipage
\visible<3->{{\LARGE$\rightarrow$}}
\minipage{0.28\textwidth}
  \visible<3->{
  \begin{center}
  \begin{tikzpicture}
  \draw[line width=0.2mm, black] (0,0) rectangle (2.6,2.24);
  \node[rectangle, align=center] (sq) at (1.3, 1.12) {\Huge{?}};
  \end{tikzpicture}
  \end{center}}
\endminipage

\minipage{0.28\textwidth}
\begin{center}
\vspace{0.0cm}
\visible<1->{
Regression Tree\\
\vspace{0.5cm}
\resizebox{0.3\textwidth}{!}{
\begin{tikzpicture}
  \node[ellipse, fill=HighlightBlue!70, align=center] (n0) at (1, 2) {};
  \node[rectangle, fill=HighlightOrange!70, align=center] (n1) at (0.5, 1) {};
  \draw[-, line width=1pt] (n0) -- (n1);
  \node[ellipse, fill=HighlightBlue!70, align=center] (n2) at (1.5, 1) {};
  \draw[-, line width=1pt] (n0) -- (n2);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n3) at (1, 0) {};
  \draw[-, line width=1pt] (n2) -- (n3);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n4) at (2, 0) {};
  \draw[-, line width=1pt] (n2) -- (n4);
\end{tikzpicture}}
\vspace{0.3cm}\\
\code{rpart}\\
\code{party(kit)}\\
\vspace{1cm}}
\end{center}
\endminipage
\hspace{0.65cm}
\minipage{0.28\textwidth}
\begin{center}
\vspace{0.0cm}
\visible<2->{
Random Forest\\
\vspace{0.5cm}
\resizebox{0.9\textwidth}{!}{
\begin{tikzpicture}
  \node[ellipse, fill=HighlightBlue!70, align=center] (n00) at (1, 2) {};
  \node[rectangle, fill=HighlightOrange!70, align=center] (n01) at (0.5, 1) {};
  \draw[-, line width=1pt] (n00) -- (n01);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n02) at (1.5, 1) {};
  \draw[-, line width=1pt] (n00) -- (n02);
  
  \node[ellipse, fill=HighlightBlue!70, align=center] (n10) at (3, 2) {};
  \node[ellipse, fill=HighlightBlue!70, align=center] (n11) at (2.5, 1) {};
  \draw[-, line width=1pt] (n10) -- (n11);
  \node[ellipse, fill=HighlightBlue!70, align=center] (n12) at (3.5, 1) {};
  \draw[-, line width=1pt] (n10) -- (n12);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n13) at (2, 0) {};
  \draw[-, line width=1pt] (n11) -- (n13);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n14) at (2.8, 0) {};
  \draw[-, line width=1pt] (n11) -- (n14);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n15) at (3.2, 0) {};
  \draw[-, line width=1pt] (n12) -- (n15);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n16) at (4, 0) {};
  \draw[-, line width=1pt] (n12) -- (n16);
  
  \node[ellipse, fill=HighlightBlue!70, align=center] (n20) at (5, 2) {};
  \node[rectangle, fill=HighlightOrange!70, align=center] (n21) at (4.5, 1) {};
  \draw[-, line width=1pt] (n20) -- (n21);
  \node[ellipse, fill=HighlightBlue!70, align=center] (n22) at (5.5, 1) {};
  \draw[-, line width=1pt] (n20) -- (n22);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n23) at (5, 0) {};
  \draw[-, line width=1pt] (n22) -- (n23);
  \node[rectangle, fill=HighlightOrange!70, align=center] (n24) at (6, 0) {};
  \draw[-, line width=1pt] (n22) -- (n24);
\end{tikzpicture}
}
\vspace{0.5cm}\\
\code{randomForest}\\
\code{ranger}\\
\code{party(kit)}\\
$\ldots$}
\end{center}
\endminipage
\hspace{0.65cm}
\minipage{0.28\textwidth}
\begin{center}
\vspace{0.68cm}
\visible<3->{
Distributional trees and forests\\
\vspace{1.7cm}
\code{disttree}\\
based on \code{partykit}\\
\vspace{1cm}}
\end{center}
\endminipage
\end{figure}
\end{frame}



\begin{frame}
\frametitle{Goals}

\textbf{Distributional:}
\begin{itemize}
  \item Specify the complete probability distribution (including location, scale, and shape).
\end{itemize}

\medskip

\textbf{Tree:}
\begin{itemize}
  \item Automatic detection of steps and abrupt changes. %(data driven)
  \item Capture non-linear and non-additive effects and interactions.
\end{itemize}

\medskip

\textbf{Forest:}
\begin{itemize}
  \item Smoother effects.
  \item Stabilization and regularization of the model.
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Distributional trees}
\vspace*{-0.12cm}
\begin{center} 
DGP:  $\; Y\ |\ X = x \; \sim  \; \mathcal{N}(\mu(x), \sigma^2(x))$
\vspace*{-0.21cm}
<<dgp_tree, echo=FALSE, results=hide>>=
data <- data.frame(x = numeric(0), x = numeric(0), x = numeric(0))
names(data) <- c("x","x","x")
fig <- party(
  partynode(1L,
            split = partysplit(2L, breaks = 0.4),
            kids = list(
              partynode(2L, info = c(
                "n = 200",
                "   True parameters:   ",
                expression(mu == '4'),
                expression(sigma == '1')
              )),
              partynode(3L,
                        split = partysplit(3L, breaks = 0.8),
                        kids = list(
                          partynode(4L, info = c(
                            "n = 200",
                            "   True parameters:   ",
                            expression(mu == '12'),
                            expression(sigma == '3')
                          )),
                          partynode(5L, info = c(
                            "n = 100",
                            "   True parameters:   ",
                            expression(mu == '4'),
                            expression(sigma == '3')
                          )))))),
  data
)


node_inner_ext <- function (obj, id = TRUE, pval = TRUE, abbreviate = FALSE, fill = "white", 
    gp = gpar()) 
{
    meta <- obj$data
    nam <- names(obj)
    extract_label <- function(node) {
        if (is.terminal(node)) 
            return(rep.int("", 2L))
        varlab <- character_split(split_node(node), meta)$name
        if (abbreviate > 0L) 
            varlab <- abbreviate(varlab, as.integer(abbreviate))
        if (pval) {
            nullna <- function(x) is.null(x) || is.na(x)
            pval <- suppressWarnings(try(!nullna(info_node(node)$p.value), 
                silent = TRUE))
            pval <- if (inherits(pval, "try-error")) 
                FALSE
            else pval
        }
        if (pval) {
            pvalue <- node$info$p.value
            plab <- ifelse(pvalue < 10^(-3L), paste("p <", 10^(-3L)), 
                paste("p =", round(pvalue, digits = 3L)))
        }
        else {
            plab <- ""
        }
        return(c(varlab, plab))
    }
    maxstr <- function(node) {
        lab <- extract_label(node)
        klab <- if (is.terminal(node)) 
            ""
        else unlist(lapply(kids_node(node), maxstr))
        lab <- c(lab, klab)
        lab <- unlist(lapply(lab, function(x) strsplit(x, "\n")))
        lab <- lab[which.max(nchar(lab))]
        if (length(lab) < 1L) 
            lab <- ""
        return(lab)
    }
    nstr <- maxstr(node_party(obj))
    if (nchar(nstr) < 6) 
        nstr <- "aAAAAa"
    rval <- function(node) {
        node_vp <- viewport(x = unit(0.5, "npc"), y = unit(0.5, 
            "npc"), width = unit(1, "strwidth", nstr) * 1.3, 
            height = unit(3, "lines"), name = paste("node_inner", 
                id_node(node), sep = ""), gp = gp)
        pushViewport(node_vp)
        xell <- c(seq(0, 0.2, by = 0.01), seq(0.2, 0.8, by = 0.05), 
            seq(0.8, 1, by = 0.01))
        yell <- sqrt(xell * (1 - xell))
        xell <- xell*1.11 - 0.055             # to adapt size of the ellipse to the size with p-value
        lab <- extract_label(node)
        fill <- rep(fill, length.out = 2L)
        grid.polygon(x = unit(c(xell, rev(xell)), "npc"), y = unit(c(yell, 
            -yell) + 0.5, "npc"), gp = gpar(fill = fill[1]))
        grid.text(lab[1L], y = unit(1.5 + 0.5,                  # to adapt position of x to its position with p-value
            "lines"))
        #grid.text(lab[1L], y = unit(1.5 + 0.5 * (lab[2L] != ""), 
        #    "lines"))
        grid.text(lab[2L], y = unit(1, "lines"))
        if (id) {
            nodeIDvp <- viewport(x = unit(0.5, "npc"), y = unit(1, 
                "npc"), width = max(unit(1, "lines"), unit(1.3, 
                "strwidth", nam[id_node(node)])), height = max(unit(1, 
                "lines"), unit(1.3, "strheight", nam[id_node(node)])))
            pushViewport(nodeIDvp)
            grid.rect(gp = gpar(fill = fill[2]))
            grid.text(nam[id_node(node)])
            popViewport()
        }
        upViewport()
    }
    return(rval)
}

class(node_inner_ext) <- "grapcon_generator"


@

\setkeys{Gin}{width=0.68\linewidth, height=0.68\linewidth}
<<plottree_dgp, fig=TRUE, echo=FALSE>>=
paltrees <- rgb(c(0.97, 0.64, 1), c(0.70, 0.83, 1), c(0.30, 0.99, 1))
plot(fig, inner_panel = node_inner_ext,
     tp_args = list(FUN = identity, width = 18, fill = paltrees[c(1, 3)]), 
     ip_args = list(fill = paltrees[c(2, 3)]),
     drop_terminal = TRUE, tnex = 1.7)
@
\end{center}
\end{frame}

<<tree, echo=FALSE, results=hide>>=
set.seed(7)
nobs <- 500
x <- runif(nobs, 0, 1)
mu <- sigma <- ytrue <- numeric(length = nobs)
for(i in 1:nobs) sigma[i] <- if(x[i]<=0.4) 1 else 3
for(i in 1:nobs) mu[i] <- if(x[i]<= 0.4|| x[i]>0.8) 4 else 12
y <- rnorm(nobs, mean = mu, sd = sigma)
#y <- rcnorm(nobs, mean = mu, sd = sigma, left = 0)
ytrue <- mu
data <- data.frame(cbind(y,x, ytrue))
tree <- disttree(y ~ x, data = data, family = NO(), type.tree = "mob")
#tree <- disttree(y ~ x, data = data, family = dist_list_cens_normal)
@

\begin{frame}[fragile]
\frametitle{Distributional trees}
\begin{center}
\vspace*{-0.12cm}
Model: \code{disttree(y ~ x)}\\
\vspace*{-0.2cm}
\setkeys{Gin}{width=0.68\linewidth, height=0.68\linewidth}
<<plottree_estpar, fig=TRUE, echo=FALSE>>=
# function for output in terminal panels
FUN <- function (x) 
{
  cf <- x$coefficients
  cf <- matrix(cf, ncol = 1, dimnames = list(names(cf), ""))
  c(sprintf("n = %s", x$nobs), "Estimated parameters:", parse(text = paste0("mu == '", format(round(cf[1], 2), nsmall = 2), "'")), 
                                                        parse(text = paste0("sigma == '", format(round(cf[2], 2), nsmall = 2), "'")))
}

paltrees <- rgb(c(0.97, 0.64, 1), c(0.70, 0.83, 1), c(0.30, 0.99, 1))

## plot version using FUN and tree of class 'disttree'
plot(tree, drop = TRUE, tnex = 1.7, FUN = FUN,
     tp_args = list(fill = paltrees[c(1, 3)], width = 18), 
     ip_args = list(fill = paltrees[c(2, 3)]))
@
\end{center}
\end{frame}


\begin{frame}[fragile]
\frametitle{Distributional trees}
\begin{center}
\vspace*{-0.12cm}
Model: \code{disttree(y ~ x)}\\
\vspace*{-0.2cm}
\setkeys{Gin}{width=0.68\linewidth, height=0.68\linewidth}
<<plottree_box, fig=TRUE, echo=FALSE>>=
plot(as.constparty(tree), tnex = 1.7, drop = TRUE,
     tp_args = list(fill = paltrees[c(1, 3)], ylines = 1.5), 
     ip_args = list(fill = paltrees[c(2, 3)]))
@
\end{center}
\end{frame}



\begin{frame}[fragile]
\frametitle{Distributional trees}
\begin{center}
\vspace*{-0.12cm}
Model: \code{disttree(y ~ x)}\\
\vspace*{-0.2cm}
\setkeys{Gin}{width=0.68\linewidth, height=0.68\linewidth}
<<plottree_dens, fig=TRUE, echo=FALSE>>=
node_density <- function (tree, xscale = NULL, yscale = NULL, horizontal = FALSE,
                          main = "", xlab = "", ylab = "Density", id = TRUE, rug = TRUE,
                          fill = paltrees[c(1, 3)], col = "black", lwd = 0.5, ...) 
{
  yobs <- tree$data[,as.character(tree$info$formula[[2]])]
  ylines <- 1.5
  if (is.null(xscale)) xscale <- c(-5.1,22.5)
  if (is.null(yscale)) yscale <- c(-0.05,0.45)
  xr <- xscale
  yr <- yscale
  
  if (horizontal) {
    yyy <- xscale
    xscale <- yscale
    yscale <- yyy
  }
  
  rval <- function(node) {
    yrange <- seq(from = -20, to = 90)/4
    ydens <- node$info$object$ddist(yrange)
    
    top_vp <- viewport(layout = grid.layout(nrow = 2, ncol = 3, 
                                            widths = unit(c(ylines, 1, 1), c("lines", "null", "lines")), 
                                            heights = unit(c(1, 1), c("lines", "null"))), 
                       width = unit(1, "npc"), 
                       height = unit(1, "npc") - unit(2, "lines"), 
                       name = paste("node_density",node$id, sep = ""))
    pushViewport(top_vp)
    grid.rect(gp = gpar(fill = "white", col = 0))
    top <- viewport(layout.pos.col = 2, layout.pos.row = 1)
    pushViewport(top)
    mainlab <- paste(ifelse(id, paste("Node", node$id, "(n = "), "n = "), node$info$nobs, ifelse(id, ")", ""), sep = "")
    
    grid.text(mainlab)
    popViewport()
    plot <- viewport(layout.pos.col = 2, layout.pos.row = 2, 
                     xscale = xscale, yscale = yscale, 
                     name = paste("node_density",  node$id, "plot", sep = ""))
    pushViewport(plot)
    yd <- ydens
    xd <- yrange
    if (horizontal) {
      yyy <- xd
      xd <- yd
      yd <- yyy
      yyy <- xr
      xr <- yr
      yr <- yyy
      rxd <- rep(0, length(xd))
      ryd <- rev(yd)
    } else {
      rxd <- rev(xd)
      ryd <- rep(0, length(yd))
    }
    
    if (rug) {
      nodeobs <- node$info$object$y
      if (horizontal) {
        grid.rect(x = xscale[1], y = nodeobs , height = 0, width = xscale[1], 
                  default.units = "native", just = c("right", "bottom"),
		  gp = gpar(lwd = 2, col = gray(0, alpha = 0.18)))
      } else {
        grid.rect(x = nodeobs, y = yscale[1], 
                  width = 0, height = abs(yscale[1]), default.units = "native", 
                  just = c("center", "bottom"),
		  gp = gpar(lwd = 2, col = gray(0, alpha = 0.18)))
        #grid.lines(x = xr, y = yr, gp = gpar(col = "lightgray"), 
        #           default.units = "native")
        #grid.lines(x = xr, y = yr, gp = gpar(col = "lightgray"), 
        #           default.units = "native")
      }
    }

    
    grid.polygon(x = c(xd, rxd), y = c(yd, ryd), default.units = "native",
              gp = gpar(col = "black", fill = fill, lwd = lwd))
    #grid.lines(x = xd, y = yd, default.units = "native", 
    #           gp = gpar(col = col, lwd = lwd))
    grid.xaxis()
    grid.yaxis()
    grid.rect(gp = gpar(fill = "transparent"))
    upViewport(2)
  }
  return(rval)
}

class(node_density) <- "grapcon_generator"

plot(tree, tnex = 1.7, drop = TRUE,
     terminal_panel = node_density,
     tp_args = list(fill = paltrees[c(1, 3)]), 
     ip_args = list(fill = paltrees[c(2, 3)]))
@
\end{center}
\end{frame}
%\begin{frame}
%\frametitle{Distributional trees}
%\center
%\vspace*{-1cm}
%\setkeys{Gin}{width=0.8\linewidth}
%\includegraphics{tree_box}
%\end{frame}



<<treedata, echo=FALSE, results=hide>>=
set.seed(54)
nobs <- 500
x <- runif(nobs, 0, 1)
mu <- sigma <- ytrue <- numeric(length = nobs)
for(i in 1:nobs) sigma[i] <- if(x[i]<=0.4) 1 else 3
for(i in 1:nobs) mu[i] <- if(x[i]<= 0.4|| x[i]>0.8) 4 else 12
y <- rnorm(nobs, mean = mu, sd = sigma)
ytrue <- mu
data <- data.frame(cbind(y,x, ytrue))

alldata <- cbind(data, mu, sigma)
odata <- alldata[order(alldata["x"]),]
@


\begin{frame}[fragile]
\frametitle{Distributional trees}
\begin{center}
\vspace*{-1.03cm}
\setkeys{Gin}{width=0.8\linewidth}
<<plottree_xyplot, fig=TRUE, echo=FALSE>>=
par(mar=c(5.1,4.1,4.1,3.1))
plot(y=odata$y, x=odata$x, ylab = "y", xlab = "x", col = "grey")
#plot(y=odata$y, x=odata$x, xaxt="n", yaxt="n", ann=FALSE, col = "slategray")
lines(x = odata$x, y = odata$mu, col = pal["forest"], lwd = 2.5, main = "")
polygon(c(odata$x, rev(odata$x)), c(odata$mu + odata$sigma, rev(odata$mu - odata$sigma)),
  col = pallight["forest"], border = "transparent")
legend(x = -0.0715, y = 21.62, expression(mu  %+-%  sigma), bty = "n")
#lines(x = odata$x, y = odata$mu + odata$sigma, col = hcl(10, 80, 70), lwd = 1.5, lty = 1)
#lines(x = odata$x, y = odata$mu - odata$sigma, col = hcl(10, 80, 70), lwd = 1.5, lty = 1)
@
\end{center}
\end{frame}


%\begin{frame}
%\frametitle{Distributional trees}
%\center
%\vspace*{-0.7cm}
%\setkeys{Gin}{width=0.8\linewidth}
%\includegraphics{tree_xyplot}
%\end{frame}


\begin{frame}
\frametitle{Global likelihood estimation}
\begin{itemize}

\item Specify a parametric distribution family $F(\cdot; \theta)$ with parameter vector
  $\theta \in \Theta$ capturing location, scale, shape.

\item Cumulative distribution function and log-likelihood:
  \begin{eqnarray*}
  F(y; \theta)    & = & \mathbb{P}_{\theta}(Y\leq y)\\
  \ell(\theta; y) & = & \log(f(y; \theta))
  \end{eqnarray*}

\item Estimate $\hat{\bold{\theta}}$ via maximum likelihood
  based on a learning sample $y_1,\dots, y_n$:
\[
\hat{\theta} = \max_{\theta \in \Theta} \sum_{i=1}^n \ell(\theta; y_i)
\]

%% equivalent to solving 
%% $$
%% \sum_{i=1}^n \frac{\partial \ell}{\partial \theta}(\hat{\theta}; y_i) = \sum_{i=1}^n s(y_i, \hat{\theta}) = 0.
%% $$
\end{itemize}


\end{frame}


\begin{frame}
\frametitle{Adaptive local likelihood estimation}

\textbf{Idea:} Covariates captured through adaptive weights.
\[
\hat{\theta}(\bold{x}) = \max_{\theta \in \Theta} \sum_{i=1}^n w_i(\bold{x}) \cdot \ell(\theta; y_i).
\]

\bigskip

\textbf{Question:} How to choose weighting function $w_i(\bold{x})$?

\bigskip

\textbf{Possible answers:} Based on learning sample $y_1, \dots, y_n$ and (possibly new) observation $\bold{x}$.
\begin{itemize}
\item \emph{Tree:} $w_i(\bold{x}) \in \{0,1\}$ indicates whether $\bold{x}$ and $y_i$ are classified into the same subgroup.
\item \emph{Forest:} $w_i(\bold{x}) \in  [0, 1]$ averages the weights for $\bold{x}$ and $y_i$ across trees.
\end{itemize}


\end{frame}



\subsection{Building distributional trees and forests}
\begin{frame}
\frametitle{Distributional trees and forests}
\textbf{Tree:}
\begin{enumerate}
\item Estimate $\hat{\theta}$ via maximum likelihood (without covariates).
\item Test for associations or instabilities of the scores $\frac{\partial \ell}{\partial \theta}(\hat{\theta};y_i)$ and each partitioning variable $x_i$.
\item Split the sample along the partitioning variable with the strongest association or instability.
    Choose breakpoint with highest improvement in log-likelihood.
\item Repeat steps 1--3 recursively until some stopping criterion is met, yielding
    $B$ subgroups $\mathcal{B}_b$ with $b = 1, \dots, B$.
\end{enumerate}

\bigskip

\textbf{Forest:} Ensemble of $T$ trees.
\begin{itemize}
\item Bootstrap or subsamples.
\item Random input variable sampling.
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Adaptive local likelihood estimation}


\textbf{Estimator:}
\[
\hat{\theta}(\bold{x}) =  \max_{\theta \in \Theta} \sum_{i=1}^n w_i(\bold{x}) \cdot \ell(\theta; y_i)
\]

\bigskip

\textbf{Weights:}

\begin{eqnarray*}
w^{\text{base}}_i(\bold{x})   & = & 1 \\[0.3cm]
w^{\text{tree}}_i(\bold{x})   & = & \sum_{b=1}^B I((\bold{x}_i \in \mathcal{B}_b) \land (\bold{x} \in \mathcal{B}_b)) \\[0.3cm]
w^{\text{forest}}_i(\bold{x}) & = & \frac{1}{T} \sum_{t=1}^T \sum_{b=1}^{B^t} I((\bold{x}_i \in \mathcal{B}^t_b) \land (\bold{x} \in \mathcal{B}^t_b))
\end{eqnarray*}

\end{frame}


\begin{frame}
\frametitle{Simulation}

\textbf{Models:} \code{disttree}, \code{distforest} (100 trees), \code{gamlss}.

\bigskip

\textbf{Data:}
\begin{eqnarray*}
  y         & \sim & \mathcal{N}(\mu(x), \sigma(x))\\
  x         & \sim & \mathcal{U}(-0.4, 1) \\
  \mu(x)    & =    & 10 \cdot \exp\left\{ -(4 \cdot x - 2)^{2 \cdot \kappa} \right\}\\
  \sigma(x) & =    & 0.5 + 2 \cdot |x|
\end{eqnarray*}

\bigskip

\textbf{Parameters:}
\begin{itemize}
  \item 1 replication: $n = 300$, $\kappa = 2$.
  \item 150 replications: $n = 1000$, $\kappa = 1, 8, 15, \dots, 71$.
\end{itemize}
\end{frame}



%\SweaveOpts{eval=FALSE}
<<sim_1dataset, echo=FALSE, results=hide>>=
set.seed(723)
fun <- function(x){cbind(10*exp(-((4*x[,1]-2)^4)), 0.5 + 2*abs(x[,1]))}
learndata <- dgp(300, family = dist_list_normal, round.sp = 4, fun = fun)
control <-  ctree_control(teststat = "quad", testtype = "Bonferroni", mincriterion = 0.7, minbucket = 20L)
dt <- disttree(y~x1, data=learndata, family=dist_list_normal, type.tree = "ctree", control = control)

if(file.exists("sim_forest.rda")){
  load("sim_forest.rda")
} else {
  control <-  ctree_control(teststat = "quad", testtype = "Univ", mincriterion = 0, minbucket = 7L)
  df <- distforest(y~x1, data=learndata, family=dist_list_normal, ntree = 500L, type.tree = "ctree", control = control)
  df$info <- df$fitted <- df$weights <- df$nodes <- df$data <- df$terms <- df$loglik <- df$trafo <- NULL
  save(df, file = "sim_forest.rda")
}

g <- gamlss(y ~ pb(x1), sigma.formula = ~pb(x1), data = learndata, trace = FALSE)
@

\begin{frame}[fragile]
\frametitle{Simulation}
\begin{center}
\vspace*{-1cm}
\setkeys{Gin}{width=0.8\linewidth}
<<oneforest_exp1, fig=TRUE, echo=FALSE>>=
plot1(learndata, dt=dt, df=df, g=g)
@
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{Simulation}
\begin{center}
\vspace*{-1cm}
\setkeys{Gin}{width=0.8\linewidth}
<<oneforest_exp1_dt, fig=TRUE, echo=FALSE>>=
plot1(learndata, dt=dt, df=df, g=g, dt.par = TRUE)
@
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{Simulation}
\begin{center}
\vspace*{-1cm}
\setkeys{Gin}{width=0.8\linewidth}
<<oneforest_exp1_g, fig=TRUE, echo=FALSE>>=
plot1(learndata, dt=dt, df=df, g=g, g.par = TRUE)
@
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{Simulation}
\begin{center}
\vspace*{-1cm}
\setkeys{Gin}{width=0.8\linewidth}
<<oneforest_exp1_df, fig=TRUE, echo=FALSE>>=
plot1(learndata, dt=dt, df=df, g=g, df.par = TRUE)
@
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{Simulation}
\begin{center}
\vspace*{-1cm}
\setkeys{Gin}{width=0.8\linewidth}
<<oneforest_exp1_all, fig=TRUE, echo=FALSE>>=
plot1(learndata, dt=dt, df=df, g=g, all.par = TRUE)
@
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{Simulation}
\begin{center}
\vspace*{-1cm}
\setkeys{Gin}{width=0.8\linewidth}
<<oneforest_exp1_allvar, fig=TRUE, echo=FALSE>>=
plot1(learndata, dt=dt, df=df, g=g, all.var = TRUE)
@
\end{center}
\end{frame}



<<get_simlist, echo=FALSE, results=hide>>=
if(file.exists("simlist.rda")){
  load("simlist.rda")
} else {
  source("gensimlist.R")
  simlist <- gensimlist(seed = 9, nrep = 150, ntree = 100)
  save(simlist, file = "simlist.rda")
}


# plots for various data sets
# results given in simlist
# plot RMSE
plot_rmse <- function(simlist, type = c("exp", "par")){
  
  if(type == "exp"){
    #dev.off() 
    rmse <- cbind(simlist$av.rmse.exp.true.dt, simlist$av.rmse.exp.true.df, simlist$av.rmse.exp.true.g,
                  simlist$av.rmse.exp.obs.dt, simlist$av.rmse.exp.obs.df, simlist$av.rmse.exp.obs.g)
    colnames(rmse) <- c("dt.true", "df.true", "g.true", "dt.obs", "df.obs", "g.obs")
    ylim <- c(min(rmse), max(rmse))
    par(mar=c(5.1,4.1,4.1,3.1))
    plot(x = simlist$x.axis, y = rmse[,"dt.true"], type = "l", col = pal["tree"], ylim = ylim,
         xlab = "", ylab = "", xaxt="n", yaxt="n", lwd = 2)
    title(main = "disttree", col.main = pal["tree"], cex.main = 1.2, font.main = 2, adj = 0.19)
    title(main = "distforest", col.main = pal["forest"], cex.main = 1.2, font.main = 2, adj = 0.5)
    title(main = "gamlss", col.main = pal["gamlss"], cex.main = 1.2, font.main = 2, adj = 0.8)
    title(main = "vs.", col.main = "black", cex.main = 1.2, font.main = 2, adj = 0.35)
    title(main = "vs.", col.main = "black", cex.main = 1.2, font.main = 2, adj = 0.65)
    lines(x = simlist$x.axis, y = rmse[,"dt.obs"], type = "l", lty = 2, col = pal["tree"], lwd = 2)
    lines(x = simlist$x.axis, y = rmse[,"df.true"], type = "l", col = pal["forest"], lwd = 2)
    lines(x = simlist$x.axis, y = rmse[,"df.obs"], type = "l", lty = 2, col = pal["forest"], lwd = 2)
    lines(x = simlist$x.axis, y = rmse[,"g.true"], type = "l", col = pal["gamlss"], lwd = 2)
    lines(x = simlist$x.axis, y = rmse[,"g.obs"], type = "l", lty = 2, col = pal["gamlss"], lwd = 2)
    #legend('left', c("disttree", "distforest", "gamlss"), col = c(pal["tree"], pal["forest"], pal["gamlss"]), lty = 1)
    mtext(text= "smooth", side = 1, line = 1, adj = 0)
    mtext(text= "steep", side = 1, line = 1, adj = 1)
    mtext(text= TeX('$\\kappa$'), side = 1, line = 1)
    mtext(text= "RMSE", side = 2, line = 1)
    mtext(text= "disttree", side = 2, col = pal["tree"], las = 1, line = 0.2, padj = 5)
    mtext(text= "distforest", side = 2, col = pal["forest"], las = 1, line = 0.2, padj = 13)
    mtext(text= "gamlss", side = 2, col = pal["gamlss"], las = 1, line = 0.3, padj = 16.5)
  
    
    # add arrows
    parsave <- par(new = TRUE,  mar = c(0,0,0,0))
    plot(0,0,xlim=c(0,1),ylim=c(0,1),type="n",xlab='', ylab='', col='white', axes = FALSE) 
    
    #add arrow on the right side (downwards, for RMSE)
    arrows(0.99,0.47, 0.99,0.3,lwd=1) ## add arrow
    text(0.99,0.5, 'better')
    segments(0.99,0.53,0.99,0.7,lwd=1)
        
    #add arrows below
    arrows(0.45,0.085,0.3,0.085,lwd=1) ## add arrow
    arrows(0.6,0.085,0.75,0.085,lwd=1) ## add arrow
    
    # plot parameters  reset to prior values
    par(parsave)
  } 
  
  if(type == "par"){
    rmse <- cbind(simlist$av.rmse.mu.dt, simlist$av.rmse.mu.df, simlist$av.rmse.mu.g, 
                  simlist$av.rmse.sigma.dt, simlist$av.rmse.sigma.df, simlist$av.rmse.sigma.g)
    colnames(rmse) <- c("mu.dt", "mu.df", "mu.g", "sigma.dt", "sigma.df", "sigma.g")
    ylim <- c(min(rmse), max(rmse))
    par(mar=c(5.1,4.1,4.1,3.1))
    plot(x = simlist$x.axis, y = rmse[,"mu.dt"], type = "l", col = pal["tree"], ylim = ylim,
         xlab = "", ylab = "", xaxt="n", yaxt="n", lwd = 2)
    title(main = "disttree", col.main = pal["tree"], cex.main = 1.2, font.main = 2, adj = 0.19)
    title(main = "distforest", col.main = pal["forest"], cex.main = 1.2, font.main = 2, adj = 0.5)
    title(main = "gamlss", col.main = pal["gamlss"], cex.main = 1.2, font.main = 2, adj = 0.8)
    title(main = "vs.", col.main = "black", cex.main = 1.2, font.main = 2, adj = 0.35)
    title(main = "vs.", col.main = "black", cex.main = 1.2, font.main = 2, adj = 0.65)
    lines(x = simlist$x.axis, y = rmse[,"sigma.dt"], type = "l", lty = 2, col = pal["tree"], lwd = 2)
    lines(x = simlist$x.axis, y = rmse[,"mu.df"], type = "l", col = pal["forest"], lwd = 2)
    lines(x = simlist$x.axis, y = rmse[,"sigma.df"], type = "l", lty = 2, col = pal["forest"], lwd = 2)
    lines(x = simlist$x.axis, y = rmse[,"mu.g"], type = "l", col = pal["gamlss"], lwd = 2)
    lines(x = simlist$x.axis, y = rmse[,"sigma.g"], type = "l", lty = 2, col = pal["gamlss"], lwd = 2)
    #legend('topleft', c("disttree", "distforest", "gamlss"), col = c(pal["tree"], pal["forest"],pal["gamlss"]), lty = 1)
    mtext(text= "smooth", side = 1, line = 1, adj = 0)
    mtext(text= "steep", side = 1, line = 1, adj = 1)
    mtext(text= TeX('$\\kappa$'), side = 1, line = 1)
    mtext(text= "RMSE", side = 2, line = 1)
    mtext(text= "disttree", side = 2, col = pal["tree"], las = 1, line = 0.2, padj = -7)
    mtext(text= "distforest", side = 2, col = pal["forest"], las = 1, line = 0.2, padj = 8)
    mtext(text= "gamlss", side = 2, col = pal["gamlss"], las = 1, line = 0.3, padj = 14)
    
    # add arrows
    parsave <- par(new = TRUE,  mar = c(0,0,0,0))
    plot(0,0,xlim=c(0,1),ylim=c(0,1),type="n",xlab='',ylab='',col='white', axes = FALSE) 
    
    #add arrow on the right side (downwards, for RMSE)
    arrows(0.99,0.47,0.99,0.3,lwd=1) ## add arrow
    text(0.99,0.5, 'better')
    segments(0.99,0.53,0.99,0.7,lwd=1)
    
    #add arrows below
    arrows(0.45,0.085,0.3,0.085,lwd=1) ## add arrow
    arrows(0.6,0.085,0.75,0.085,lwd=1) ## add arrow
    
    # plot parameters  reset to prior values
    par(parsave)
  }
}

# plot loglikelihood
plot_ll <- function(simlist){
  ll <- cbind(simlist$av.loglik.dt, simlist$av.loglik.df, simlist$av.loglik.g)
  colnames(ll) <- c("dt", "df","g")
  ylim <- c(min(ll), max(ll))
  par(mar=c(5.1,4.1,4.1,3.1))
  plot(x = simlist$x.axis, y = ll[,"dt"], type = "l", col = pal["tree"], ylim = ylim,
       xlab = "", ylab = "", xaxt="n", yaxt="n", lwd = 2)
  axis(1, at=c(1,71), lab=c(1, 71), mgp=c(3, .5, 0))
  title(main = "disttree", col.main = pal["tree"], cex.main = 1.2, font.main = 2, adj = 0.19)
  title(main = "distforest", col.main = pal["forest"], cex.main = 1.2, font.main = 2, adj = 0.5)
  title(main = "gamlss", col.main = pal["gamlss"], cex.main = 1.2, font.main = 2, adj = 0.8)
  title(main = "vs.", col.main = "black", cex.main = 1.2, font.main = 2, adj = 0.35)
  title(main = "vs.", col.main = "black", cex.main = 1.2, font.main = 2, adj = 0.65)
    
  lines(x = simlist$x.axis, y = ll[,"df"], type = "l", col = pal["forest"], lwd = 2)
  lines(x = simlist$x.axis, y = ll[,"g"], type = "l", col = pal["gamlss"], lwd = 2)
  #legend('topright', c("disttree", "distforest", "gamlss"), col = c(pal["tree"], pal["forest"],pal["gamlss"]), lty = 1)
  #mtext(text= "disttree", side = 3, col = pal["tree"], line = 1, adj = 0.3)
  #mtext(text= "distforest", side = 3, col = pal["forest"], line = 1, adj = 0.5)
  #mtext(text= "gamlss", side = 3, col = pal["gamlss"], line = 1, adj = 0.7)
  #mtext(text= "vs.", side = 3, col = "black", line = 1, adj = 0.4)
  #mtext(text= "vs.", side = 3, col = "black", line = 1, adj = 0.6)
  mtext(text= "smooth", side = 1, line = 2, adj = 0)
  mtext(text= "steep", side = 1, line = 2, adj = 1)
  mtext(text= TeX('$\\kappa$'), side = 1, line = 2)
  mtext(text= "Log-Likelihood", side = 2, line = 1)
  mtext(text= "disttree", side = 2, col = pal["tree"], las = 1, line = 0.2, padj = 16.7)
  mtext(text= "distforest", side = 2, col = pal["forest"], las = 1, line = 0.2, padj = -8)
  mtext(text= "gamlss", side = 2, col = pal["gamlss"], las = 1, line = 0.3, padj = -16)
  
  # add arrows
  parsave <- par(new = TRUE,  mar = c(0,0,0,0))
  plot(0,0,xlim=c(0,1),ylim=c(0,1),type="n",xlab='', ylab='', col='white', axes = FALSE) 
  
  #add arrow on the right side (upwards, for LL)
  arrows(0.99,0.53,0.99,0.7,lwd=1) ## add arrow
  text(0.99,0.5, 'better')
  segments(0.99,0.3,0.99,0.47,lwd=1)
    
  #add arrows below
  arrows(0.45,0.047,0.3,0.047,lwd=1) ## add arrow
  arrows(0.6,0.047,0.75,0.047,lwd=1) ## add arrow
    
  # plot parameters  reset to prior values
  par(parsave)
}
@


\begin{frame}[fragile]
\frametitle{Simulation}
\begin{center}
\vspace*{-1cm}
\setkeys{Gin}{width=0.8\linewidth}
<<plotsim_ll, fig=TRUE, echo=FALSE>>=
plot_ll(simlist)
@
\end{center}
\end{frame}




%\begin{frame}[fragile]
%\frametitle{Simulation}
%\begin{center}
%\vspace*{-1cm}
%\setkeys{Gin}{width=0.8\linewidth}
%\includegraphics{sim_ll}
%\end{center}
%\end{frame}

%\begin{frame}[fragile]
%\frametitle{Simulation}
%\begin{center}
%\vspace*{-1cm}
%\setkeys{Gin}{width=0.8\linewidth}
%\includegraphics{sim_RMSE_par}
%\end{center}
%\end{frame}

%\begin{frame}[fragile]
%\frametitle{Simulation}
%\begin{center}
%\vspace*{-1cm}
%\setkeys{Gin}{width=0.8\linewidth}
%\includegraphics{sim_RMSE_exp}
%\end{center}
%\end{frame}




\begin{frame}
\frametitle{Model specification}

\textbf{Covariates:} Automatically through adaptive forest weights.

\bigskip

\textbf{Response:} Distributional specification needed.
\begin{itemize}
\item Continuous responses: Gaussian, \dots
\item Limited responses: Censored Gaussian, \dots
\item Survival times: Exponential, Weibull, \dots
\item Count: Poisson, negative binomial, \dots
\end{itemize}

\bigskip

\textbf{Guidance:} Literature, theory, experience, \dots

\bigskip

\textbf{Alternative:} Transformation models.

\end{frame}


\begin{frame}
\frametitle{Transformation models}

\textbf{Advantages:}
\begin{itemize}
\item Does not require specification of distribution family.
\item More flexible framework.
\end{itemize}

\bigskip

\textbf{Distribution function:}
\[
F(y; \theta) = \Phi(\bold{a}_{Bs,d}(y)^\top \theta) 
\]
\begin{itemize} 
\item $\bold{a}_{Bs,d}(y)^\top \theta$ is a smooth, monotone Bernstein polynomial of degree $d$.
\item $d=1$ corresponds to $\mathcal{N}(\mu,\sigma^2)$.
\item $d=5$ is surprisingly flexible.
\end{itemize}

\medskip

\textbf{Example:} Body Mass Index explained by lifestyle factors (Switzerland).

\end{frame}

\begin{frame}
\frametitle{Transformation models}

\vspace*{0.4cm}
\includegraphics[width=1.05\textwidth]{cmpx-tree.pdf}

\end{frame}


\begin{frame}
\frametitle{Software}
\vspace{0.4cm}
\textbf{Package:} \emph{disttree} available on R-Forge at\\

\medskip

\url{https://R-Forge.R-project.org/projects/partykit/}\\

\bigskip
\bigskip

\textbf{Main functions:}

\medskip

\begin{tabular}{ll}
\code{distfit}    & Distributional fit (ML, \code{gamlss.family}/custom \code{list}).\\
                  & No covariates. \\
\code{disttree}   & Distributional tree (\code{ctree}/\code{mob} + \code{distfit}).\\
                  & Covariates as partitioning variables. \\
\code{distforest} & Distributional forest (\code{disttree} ensemble).\\
                  & Covariates as partitioning variables.
\end{tabular}

\end{frame}





\subsection{References}

\begin{frame}
\frametitle{References}

\footnotesize

Schlosser L, Hothorn T, Stauffer R, Zeileis A (2018).
  \dquote{Distributional Regression Forests for Probabilistic Precipitation Forecasting in Complex Terrain.}
  \emph{Manuscript under preparation}.

\medskip

Hothorn T, Zeileis A (2017).
  \dquote{Transformation Forests.}
  \emph{arXiv 1701.02110}, arXiv.org E-Print Archive.
  \url{http://arxiv.org/abs/1701.02110}

\medskip

Hothorn T, Zeileis A (2015).
 \dquote{partykit: A Modular Toolkit for Recursive Partytioning in R.}
 \textit{Journal of Machine Learning Research},
 \textbf{16}, 3905--3909.
 \url{http://www.jmlr.org/papers/v16/hothorn15a.html}

\medskip

Hothorn T, Hornik K, Zeileis A (2006).
 \dquote{Unbiased Recursive Partitioning: A Conditional Inference Framework.}
 \textit{Journal of Computational and Graphical Statistics},
 \textbf{15}(3), 651--674.
 \doi{10.1198/106186006X133933}
 
\medskip

Zeileis A, Hothorn T, Hornik K (2008).
 \dquote{Model-Based Recursive Partitioning.}
  \textit{Journal of Computational and Graphical Statistics},
  \textbf{17}(2), 492--514.
  \doi{10.1198/106186008X319331}

\medskip

Stasinopoulos DM, Rigby RA (2007).
  \dquote{Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.}
  \textit{Journal of Statistical Software}, 
  \textbf{23}(7), 1--46.
  \doi{10.18637/jss.v023.i07}
  
\end{frame}


\end{document}




