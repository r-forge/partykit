}
subsampledata <- data[subsample,]
# Make sure ctree() can find object specified by weights argument:
environment(formula) <- environment()
# Grow ctree on subsample:
tree <- ctree(formula, data = subsampledata, weights = weights[subsample],
maxdepth = maxdepth, mtry = mtry)
# Collect rules from tree:
rules <- append(rules, unlist(partykit:::.list.rules.party(tree)))
}
}
}
if(learnrate > 0) { # use glmtree with offset arg when learning rate > 0
current_offset <- rep(0, times = nrow(data))
for(i in 1:ntrees) {
while(length(rules) <= maxrules) {
print(c("Let's grow tree number", i))
# Take subsample of dataset
treecount <- treecount + 1
if(sampfrac == 1) { # then bootstrap
subsample <- sample(1:n, size = n, replace = TRUE)
} else { # else subsample
subsample <- sample(1:n, size = round(sampfrac * n), replace = FALSE)
}
subsampledata <- data[subsample,]
curr_offs <- current_offset
# Make sure ctree() can find object specified by weights argument:
environment(formula) <- environment()
# Grow ctree on subsample:
tree <- glmtree(formula, data = subsampledata, family = "binomial",
weights = weights[subsample], maxdepth = maxdepth,
offset = curr_offs[subsample])
print(c("tree number", i, "grown"))
# Collect rules from tree:
rules <- append(rules, unlist(partykit:::.list.rules.party(tree)))
# Calculate new offset:
print(current_offset)
print(curr_offs)
curr_offs <- curr_offs + learnrate * predict(tree, newdata = data)
}
}
}
}
nrules <- length(rules)
if(verbose){
cat("\nA total of", treecount, "trees were grown, and a total of", nrules,
"rules were generated initally.")
}
# Keep unique, non-empty rules only:
rules <- unique(rules[!rules==""])
if(verbose) {
cat("\n\nA total of", nrules - length(rules), "rules were duplicates and
removed from the initial ensemble.")
}
# Create dataframe with 0-1 coded rules:
rulevars <- data.frame(
rule1 = as.numeric(with(data, eval(parse(text = rules[[1]])))))
for(i in 2:length(rules)) {
rulevars[,paste("rule", i, sep="")] <- as.numeric(
with(data, eval(parse(text = rules[[i]]))))
}
if(removeduplicates) {
# Remove rules with identical support:
duplicates <- duplicated(t(rulevars))
duplicates.removed <- data.frame(name = colnames(rulevars)[duplicates],
description = rules[duplicates])
rulevars <- rulevars[,!duplicates]
rules <- rules[!duplicates]
if(verbose) {
cat("\n\nA total of", length(duplicates.removed), "generated rules had
support identical to earlier rules and were removed from the initial
ensemble ($duplicates.removed shows which, if any).")
}
} else {
duplicates.removed <- NULL
}
if(verbose) {
cat("\n\nAn initial ensemble consisting of", ncol(rulevars), "rules was
succesfully created.")
}
}
data <- airq.f
current_offset <- rep(0, times = nrow(data))
for(i in 1:ntrees) {
while(length(rules) <= maxrules) {
print(c("Let's grow tree number", i))
# Take subsample of dataset
treecount <- treecount + 1
if(sampfrac == 1) { # then bootstrap
subsample <- sample(1:n, size = n, replace = TRUE)
} else { # else subsample
subsample <- sample(1:n, size = round(sampfrac * n), replace = FALSE)
}
subsampledata <- data[subsample,]
curr_offs <- current_offset
# Make sure ctree() can find object specified by weights argument:
environment(formula) <- environment()
# Grow ctree on subsample:
tree <- glmtree(formula, data = subsampledata, family = "binomial",
weights = weights[subsample], maxdepth = maxdepth,
offset = curr_offs[subsample])
print(c("tree number", i, "grown"))
# Collect rules from tree:
rules <- append(rules, unlist(partykit:::.list.rules.party(tree)))
# Calculate new offset:
print(current_offset)
print(curr_offs)
curr_offs <- curr_offs + learnrate * predict(tree, newdata = data)
}
}
cur_offs
curr_offs
learnrate
data
formula
treecount <- treecount + 1
if(sampfrac == 1) { # then bootstrap
subsample <- sample(1:n, size = n, replace = TRUE)
} else { # else subsample
subsample <- sample(1:n, size = round(sampfrac * n), replace = FALSE)
}
subsampledata <- data[subsample,]
curr_offs <- current_offset
# Make sure ctree() can find object specified by weights argument:
environment(formula) <- environment()
# Grow ctree on subsample:
tree <- glmtree(formula, data = subsampledata, family = "binomial",
weights = weights[subsample], maxdepth = maxdepth,
offset = curr_offs[subsample])
tree
print(c("tree number", i, "grown"))
# Collect rules from tree:
rules <- append(rules, unlist(partykit:::.list.rules.party(tree)))
# Calculate new offset:
print(current_offset)
print(curr_offs)
curr_offs <- curr_offs + learnrate * predict(tree, newdata = data)
curr_offs
length(curr_offs)
length(predict(tree, newdata = data))
for(i in 1:ntrees) {
while(length(rules) <= maxrules) {
print(c("Let's grow tree number", i))
# Take subsample of dataset
treecount <- treecount + 1
if(sampfrac == 1) { # then bootstrap
subsample <- sample(1:n, size = n, replace = TRUE)
} else { # else subsample
subsample <- sample(1:n, size = round(sampfrac * n), replace = FALSE)
}
subsampledata <- data[subsample,]
curr_offs <- current_offset
# Make sure ctree() can find object specified by weights argument:
environment(formula) <- environment()
# Grow ctree on subsample:
tree <- glmtree(formula, data = subsampledata, family = "binomial",
weights = weights[subsample], maxdepth = maxdepth,
offset = curr_offs[subsample])
print(c("tree number", i, "grown"))
# Collect rules from tree:
rules <- append(rules, unlist(partykit:::.list.rules.party(tree)))
# Calculate new offset:
curr_offs <- curr_offs + learnrate * predict(tree, newdata = data,
offset = rep(0, times = nrow(data)))
}
}
rules
print(c("Let's grow tree number", i))
# Take subsample of dataset
treecount <- treecount + 1
if(sampfrac == 1) { # then bootstrap
subsample <- sample(1:n, size = n, replace = TRUE)
} else { # else subsample
subsample <- sample(1:n, size = round(sampfrac * n), replace = FALSE)
}
subsampledata <- data[subsample,]
curr_offs <- current_offset
# Make sure ctree() can find object specified by weights argument:
environment(formula) <- environment()
# Grow ctree on subsample:
tree <- glmtree(formula, data = subsampledata, family = "binomial",
weights = weights[subsample], maxdepth = maxdepth,
offset = curr_offs[subsample])
print(c("tree number", i, "grown"))
# Collect rules from tree:
rules <- append(rules, unlist(partykit:::.list.rules.party(tree)))
# Calculate new offset:
curr_offs <- curr_offs + learnrate * predict(tree, newdata = data,
offset = rep(0, times = nrow(data)))
?glmtree
# Take subsample of dataset
treecount <- treecount + 1
data$offset <- rep(0, times = nrow(data))
for(i in 1:ntrees) {
while(length(rules) <= maxrules) {
print(c("Let's grow tree number", i))
# Take subsample of dataset
treecount <- treecount + 1
if(sampfrac == 1) { # then bootstrap
subsample <- sample(1:n, size = n, replace = TRUE)
} else { # else subsample
subsample <- sample(1:n, size = round(sampfrac * n), replace = FALSE)
}
subsampledata <- data[subsample,]
# Make sure ctree() can find object specified by weights argument:
environment(formula) <- environment()
# Grow ctree on subsample:
tree <- glmtree(formula, data = subsampledata, family = "binomial",
weights = weights[subsample], maxdepth = maxdepth,
offset = offset)
print(c("tree number", i, "grown"))
# Collect rules from tree:
rules <- append(rules, unlist(partykit:::.list.rules.party(tree)))
# Calculate new offset:
data$offset <- data$offset + learnrate * predict(tree, newdata = data)
}
}
print(c("Let's grow tree number", i))
# Take subsample of dataset
treecount <- treecount + 1
if(sampfrac == 1) { # then bootstrap
subsample <- sample(1:n, size = n, replace = TRUE)
} else { # else subsample
subsample <- sample(1:n, size = round(sampfrac * n), replace = FALSE)
}
subsampledata <- data[subsample,]
# Make sure ctree() can find object specified by weights argument:
environment(formula) <- environment()
# Grow ctree on subsample:
tree <- glmtree(formula, data = subsampledata, family = "binomial",
weights = weights[subsample], maxdepth = maxdepth,
offset = offset)
print(c("tree number", i, "grown"))
# Collect rules from tree:
rules <- append(rules, unlist(partykit:::.list.rules.party(tree)))
# Calculate new offset:
data$offset <- data$offset + learnrate * predict(tree, newdata = data)
data$offset <- rep(0, times = nrow(data))
print(c("Let's grow tree number", i))
# Take subsample of dataset
treecount <- treecount + 1
if(sampfrac == 1) { # then bootstrap
subsample <- sample(1:n, size = n, replace = TRUE)
} else { # else subsample
subsample <- sample(1:n, size = round(sampfrac * n), replace = FALSE)
}
subsampledata <- data[subsample,]
# Make sure ctree() can find object specified by weights argument:
environment(formula) <- environment()
# Grow ctree on subsample:
tree <- glmtree(formula, data = subsampledata, family = "binomial",
weights = weights[subsample], maxdepth = maxdepth,
offset = offset)
print(c("tree number", i, "grown"))
# Collect rules from tree:
rules <- append(rules, unlist(partykit:::.list.rules.party(tree)))
# Calculate new offset:
tmpoffset <- data$offset
data$offset <- 0
data$offset <- tmpoffset + learnrate * predict(tree, newdata = data)
if(learnrate > 0) { # use glmtree with offset arg when learning rate > 0
data$offset <- rep(0, times = nrow(data))
for(i in 1:ntrees) {
while(length(rules) <= maxrules) {
print(c("Let's grow tree number", i))
# Take subsample of dataset
treecount <- treecount + 1
if(sampfrac == 1) { # then bootstrap
subsample <- sample(1:n, size = n, replace = TRUE)
} else { # else subsample
subsample <- sample(1:n, size = round(sampfrac * n), replace = FALSE)
}
subsampledata <- data[subsample,]
# Make sure ctree() can find object specified by weights argument:
environment(formula) <- environment()
# Grow ctree on subsample:
tree <- glmtree(formula, data = subsampledata, family = "binomial",
weights = weights[subsample], maxdepth = maxdepth,
offset = offset)
print(c("tree number", i, "grown"))
# Collect rules from tree:
rules <- append(rules, unlist(partykit:::.list.rules.party(tree)))
# Calculate new offset:
tmpoffset <- data$offset
data$offset <- 0
data$offset <- tmpoffset + learnrate * predict(tree, newdata = data)
}
}
}
source("C:/Users/tobii/Desktop/swReg/upre/R/upre.R")
airq.ens.f2 <- upre(Ozone ~ ., data=airq.f)
ntrees
library(partykit)
library(glmnet)
library(MatrixModels)
source("C:/Users/tobii/Desktop/swReg/upre/R/upre.R")
airq <- airquality[complete.cases(airquality),]
airq.ens <- upre(Ozone ~ ., data=airq)
airq.ens.f <- upre(Ozone ~ ., data=airq.f, learnrate = 0)
airq.f <- airq
airq.f$Ozone <- factor(airq$Ozone > median(airq$Ozone))
airq.ens.f <- upre(Ozone ~ ., data=airq.f, learnrate = 0)
airq.ens.f2 <- upre(Ozone ~ ., data=airq.f)
source("C:/Users/tobii/Desktop/swReg/upre/R/upre.R")
airq.ens <- upre(Ozone ~ ., data=airq)
source("C:/Users/tobii/Desktop/swReg/upre/R/upre.R")
airq.ens <- upre(Ozone ~ ., data=airq)
source("C:/Users/tobii/Desktop/swReg/upre/R/upre.R")
airq.ens <- upre(Ozone ~ ., data=airq)
airq.ens.f <- upre(Ozone ~ ., data=airq.f, learnrate = 0)
airq.ens.f2 <- upre(Ozone ~ ., data=airq.f)
?predict
?predict.lm
?predict.glmtree
?predict
?predict.glmnet
?predict.glm
predict.glmnet
?predict.glmnet
source("C:/Users/tobii/Desktop/swReg/upre/R/upre.R")
predict(airq.ens.f)
predict(airq.ens.f, type = "response")
predict(airq.ens.f)
predict(airq.ens.f, type = "response")
predict(airq.ens.f, type = "class")
predict(airq.ens.f2)
predict(airq.ens.f2, type = "response")
predict(airq.ens.f2, type = "class")
source("C:/Users/tobii/Desktop/swReg/upre/R/upre.R")
airq.coefs <- coef(airq.ens)
airq.coefs[airq.coefs$coefficient>0,]
importance(airq.ens)
predict(airq.ens)
plot(airq.ens$glmnet.fit)
airq.f.coefs <- coef(airq.ens.f)
airq.f.coefs[airq.f.coefs$coefficient>0,]
importance(airq.ens.f)
predict(airq.ens.f)
plot(airq.ens.f$glmnet.fit)
singleplot(airq, "Temp")
singleplot(airq.ens, "Temp")
singleplot(airq.ens, "Temp")
interact(airq.ens, "Temp")
interact(airq.ens, "Temp")
interact(airq.ens)
interact(airq.ens)
singleplot(airq.ens.f, "Temp")
singleplot(airq.ens.f2, "Temp")
setwd("./upre")
setwd("C:/Users/tobii/Desktop/swReg")
library(devtools)
library(roxygen2)
setwd("./upre")
document()
setwd("..")
check("upre")
?glmtree
setwd("./upre")
document()
setwd("./upre")
document()
setwd("..")
check("upre")
setwd("..")
check("upre")
setwd("C:/Users/tobii/Desktop/swReg")
setwd("./upre")
document()
document()
setwd("..")
check("upre")
document()
setwd("./upre")
document()
setwd("..")
check("upre")
x_names <- c("x1", "x2")
y_name <- y
y_name <- "y"
# prepare glmtree formule y ~ 1 | x1 + x2 + ...
formula(paste(paste(y_name, " ~ 1 |"), paste(x_names,
collapse = "+")))
library(partykit)
library(glmnet)
library(MatrixModels)
source("C:/Users/tobii/Desktop/swReg/upre/R/upre.R")
## test on air quality data:
airq <- airquality[complete.cases(airquality),]
dim(airq)
# some tests to see what ctree does with factors:
plot(ctree(Ozone ~ ., data=airq))
airq.f <- airq
airq.f$Ozone <- factor(airq$Ozone > median(airq$Ozone))
plot(ctree(Ozone ~ ., data=airq.f))
airq.f2 <- airq
airq.f2$Ozone <- cut(airq$Ozone, breaks = 4)
plot(ctree(Ozone ~ ., data=airq.f2))
tmp <- airq$Temp
# ctree does not require a family. Automatically uses continous or (multi)nominal methods.
# if learning rate > 0, ctree cannot be used for factors, as it does not take offset argument,
# but glmtree does. Note: this gives a different tree than ctree!
plot(glmtree(Ozone ~ 1 | Temp, data=airq.f, family = "binomial", offset = tmp))
predict(glmtree(Ozone ~ 1 | Temp, data=airq.f, family = "binomial"), newdata = airq.f)
plot(glmtree(Ozone ~ 1 | Temp, data=airq.f, family = "binomial", offset = tmp))
predict(glmtree(Ozone ~ 1 | Temp, data=airq.f, family = "binomial"), newdata = airq.f)
airq.ens <- upre(Ozone ~ ., data=airq)
airq.ens.f <- upre(Ozone ~ ., data=airq.f, learnrate = 0)
airq.ens.f2 <- upre(Ozone ~ ., data=airq.f)
ctree(Ozone ~ offset(Temp), data=airq.f)
ctree(Ozone ~ offset(Temp) + Temp, data=airq.f)
ctree(Ozone ~ offset(Temp) + Temp, data=airq.f)
ctree(Ozone ~ Temp, data=airq.f)
plot(ctree(Ozone ~ offset(Temp) + Temp, data=airq.f))
plot(ctree(Ozone ~ Temp, data=airq.f))
?glmtree
?offset
airq.ens.f2 <- upre(Ozone ~ ., data=airq.f, learnrate = .000001)
setwd("./upre")
document()
setwd("..")
check("upre")
uninstall("upre")
predict(airq.ens.f)
predict(airq.ens.f, type = "response")
predict(airq.ens.f, type = "class")
predict(airq.ens.f2)
predict(airq.ens.f2, type = "response")
predict(airq.ens.f2, type = "class")
airq.coefs <- coef(airq.ens)
airq.coefs[airq.coefs$coefficient>0,]
importance(airq.ens)
plot(airq.ens$glmnet.fit)
airq.f.coefs <- coef(airq.ens.f)
airq.f.coefs[airq.f.coefs$coefficient>0,]
importance(airq.ens.f)
plot(airq.ens.f$glmnet.fit)
singleplot(airq.ens, "Temp")
## FIXME: interact does not work anymore...
interact(airq.ens)
interact(airq.ens, "Temp")
singleplot(airq.ens.f, "Temp")
singleplot(airq.ens.f2, "Temp")
airq.nullmods <- bsnullinteract(airq.ens, nsamp = 1, seed = 42)
sample(1:k)
k<-10
sample(1:k)
exp_dataset
airq$ids <- sample(1:2)
?sample
source("C:/Users/tobii/Desktop/swReg/upre/R/upre.R")
interact(airq.ens, "Temp")
source("C:/Users/tobii/Desktop/swReg/upre/R/upre.R")
interact(airq.ens, "Temp")
singleplot(airq.ens.f, "Temp")
singleplot(airq.ens.f2, "Temp")
## test on psychological data:
library(foreign)
cardata <- read.spss("data Carillo et al.sav", to.data.frame = TRUE)
setwd("C:/Users/tobii/Desktop/swReg/upre/paper")
library(foreign)
cardata <- read.spss("data Carillo et al.sav", to.data.frame = TRUE)
summary(cardata)
car.ens <- upre(bdi ~ ., data=cardata[1:100,], lambda = seq(0, 10, by = .1))
plot(car.ens$glmnet.fit)
coefs <- coef(car.ens)
# something going wrong here:
preds <- predict(car.ens, newdata = cardata[101:111,])
cor(preds, cardata$bdi[101:111])
cor(preds, cardata$bdi[101:111])^2 * var(cardata$bdi[101:111])
coefs
singleplot(car.ens, "ntot")
pairplot(car.ens, c("n3","ntot"))
importance(car.ens)
cardata.fac <- cardata
cardata.fac[,"open4"] <- factor(cut(cardata.fac[,"open4"], breaks = 8, labels = FALSE))
sapply(cardata.fac, is.factor)
car.ens.fac <- upre(bdi ~ ., data=cardata.fac[1:100,], ctreecontrol = ctree_control(alpha = .10))
car.ens.fac <- upre(bdi ~ ., data=cardata.fac[1:100,], ctreecontrol = ctree_control(alpha = .10))
plot(car.ens$glmnet.fit)
coefs <- coef(car.ens.fac)
predict(car.ens.fac, newdata = cardata.fac[101:111,])
singleplot(car.ens.fac, "open4")
pairplot(car.ens.fac, c("n1","open4"))
importance(car.ens)
## Test on simulated data:
source("simulated data.R")
# Derive rule ensemble:
sim.ens <- upre(y ~ ., data=simdata2[1:400,])
plot(sim.ens$glmnet.fit)
plot(sim.ens$glmnet.fit)
# Get coefficients:
coefs <- coef.upre(sim.ens, penalty.par.val = "lambda.min")
# Get predictions and assess accuracy:
preds <- predict.upre(sim.ens, newdata = simdata[401:500,-11], penalty.par.val = "lambda.min")
preds <- predict.upre(sim.ens, newdata = simdata[401:500,], penalty.par.val = "lambda.min")
colnames(sim.ens$modmat)
cor(preds, simdata$y[401:500])
varnames <- paste("x", 1:10, sep="")
for(i in 1:10) {
singleplot(sim.ens, varnames[i], nvals = 10)
}
# X1 and 2, x3 and 4, x5 and 6 should show interaction:
pairplot(sim.ens, c("x1","x2"), nvals = c(5,5), phi = 45, theta = 315)
finalimps <- importance(sim.ens)
sum(finalimps$varimps$imp)
sum(finalimps$baseimps$imp)
# calculate local importances:
importance(sim.ens)
# gives an error:
importance(sim.ens, global = FALSE)
nullmods <- bsnullinteract(sim.ens, nsamp = 2)
int.bs <- interact(sim.ens, paste("x", 1:10, sep=""), nullmods)
